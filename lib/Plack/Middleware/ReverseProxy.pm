package Plack::Middleware::ReverseProxy;

use strict;
use warnings;
use 5.008_001;
use parent qw(Plack::Middleware);
use Plack::Util::Accessor qw(headers);
our $VERSION = '0.07';

sub new {
    my $self = shift->SUPER::new(@_);
    $self->headers({ map { $_ => 1 } @{ $self->headers || [qw(
        HTTP_X_FORWARDED_HTTPS
        HTTP_X_FORWARDED_PROTO
        HTTP_X_FORWARDED_FOR
        HTTP_X_FORWARDED_HOST
        HTTP_X_FORWARDED_PORT
        HTTTP_HOST
    )] } });
    return $self;
}

sub call {
    my $self = shift;
    my $env = shift;
    my $allowed = $self->headers;

    # in apache httpd.conf (RequestHeader set X-Forwarded-HTTPS %{HTTPS}s)
    $env->{HTTPS} = $env->{'HTTP_X_FORWARDED_HTTPS'}
        if $allowed->{HTTP_X_FORWARDED_HTTPS} && $env->{HTTP_X_FORWARDED_HTTPS};
    $env->{HTTPS} = 'ON'
        if $allowed->{HTTP_X_FORWARDED_PROTO} && $env->{HTTP_X_FORWARDED_PROTO}; # Pound
    $env->{'psgi.url_scheme'}  = 'https' if $env->{HTTPS} && uc $env->{HTTPS} eq 'ON';
    my $default_port = $env->{'psgi.url_scheme'} eq 'https' ? 443 : 80;

    # If we are running as a backend server, the user will always appear
    # as 127.0.0.1. Select the most recent upstream IP (last in the list)
    if ( $allowed->{HTTP_X_FORWARDED_FOR} && $env->{HTTP_X_FORWARDED_FOR} ) {
        my ( $ip, ) = $env->{HTTP_X_FORWARDED_FOR} =~ /([^,\s]+)$/;
        $env->{REMOTE_ADDR} = $ip;
    }

    if ( $allowed->{HTTP_X_FORWARDED_HOST} && $env->{HTTP_X_FORWARDED_HOST} ) {
        my ( $host, ) = $env->{HTTP_X_FORWARDED_HOST} =~ /([^,\s]+)$/;
        if ( $host =~ /^(.+):(\d+)$/ ) {
#            $host = $1;
            $env->{SERVER_PORT} = $2;
        } elsif ( $allowed->{HTTP_X_FORWARDED_PORT} && $env->{HTTP_X_FORWARDED_PORT} ) {
            # in apache httpd.conf (RequestHeader set X-Forwarded-Port 8443)
            $env->{SERVER_PORT} = $env->{HTTP_X_FORWARDED_PORT};
            $host .= ":$env->{SERVER_PORT}";
            $env->{'psgi.url_scheme'} = 'https'
                if $env->{SERVER_PORT} == 443;
        } else {
            $env->{SERVER_PORT} = $default_port;
        }
        $env->{HTTP_HOST} = $host;

    } elsif ( $allowed->{HTTP_HOST} && $env->{HTTP_HOST} ) {
        my $host = $env->{HTTP_HOST};
        if ($host =~ /^(.+):(\d+)$/ ) {
#            $env->{HTTP_HOST}   = $1;
            $env->{SERVER_PORT} = $2;
        } elsif ($host =~ /^(.+)$/ ) {
            $env->{HTTP_HOST}   = $1;
            $env->{SERVER_PORT} = $default_port;
        }
    }

    $env->{SCRIPT_NAME} = $env->{HTTP_X_FORWARDED_SCRIPT_NAME}
        if $allowed->{HTTP_X_FORWARDED_SCRIPT_NAME} && $env->{HTTP_X_FORWARDED_SCRIPT_NAME};

    $env->{PATH_INFO} = $env->{HTTP_X_FORWARDED_PATH_INFO}
        if $allowed->{HTTP_X_FORWARDED_PATH_INFO} && $env->{HTTP_X_FORWARDED_PATH_INFO};

    $self->app->($env);
}

1;

__END__

=head1 NAME

Plack::Middleware::ReverseProxy - Supports app to run as a reverse proxy backend

=head1 SYNOPSIS

  builder {
      enable_if {
          $_[0]->{REMOTE_ADDR} eq '127.0.0.1'
      } 'ReverseProxy', headers => [qw(
          HTTP_X_FORWARDED_FOR
          HTTP_X_FORWARDED_HOST
          HTTP_X_FORWARDED_SERVER
      )];
      $app;
  };

=head1 DESCRIPTION

Plack::Middleware::ReverseProxy modifies the environment based on the values
of some HTTP headers set by a reverse proxy server. You can specify the
reverse proxy address and stop fake requests using the C<enable_if> directive
in your C<app.psgi>.

Plack::Middleware::ReverseProxy will make modifications to the environment
based on the values in the following keys:

=over

=item C<HTTP_X_FORWARDED_HTTPS>

=item C<HTTP_X_FORWARDED_PROTO>

=item C<HTTP_X_FORWARDED_FOR>

=item C<HTTP_X_FORWARDED_HOST>

=item C<HTTP_X_FORWARDED_PORT>

=item C<HTTTP_HOST>

=item C<HTTP_X_FORWARDED_SCRIPT_NAME>

=item C<HTTP_X_FORWARDED_PATH_INFO>

=back

All but the last two are checked by default unless you pass an explicit list
of headers. However, for the best security, you should configure it to use
only the the headers actually generated by your reverse proxy server. Check
the documentation for your reverse proxy server to see what headers it sets.
For example, the L<headers set by
mod_proxy|http://httpd.apache.org/docs/2.2/mod/mod_proxy.html#x-headers> are
C<X-Forwarded-For>, C<X-Forwarded-Host>, and C<X-Forwarded-Server>. So you
should enable Plack::Middleware::ReverseProxy like so:

  enable 'ReverseProxy', headers => [qw(
      HTTP_X_FORWARDED_FOR
      HTTP_X_FORWARDED_HOST
      HTTP_X_FORWARDED_SERVER
  )];

This prevents Plack::Middleware::ReverseProxy from inspecting other headers,
such as C<HTTP_X_FORWARDED_PROTO>, which, since they're not set by the reverse
proxy server, could be spoofed by the incoming HTTP request.

=head1 LICENSE

This software is licensed under the same terms as Perl itself.

=head1 AUTHOR

This module is originally written by Kazuhiro Osawa as
L<HTTP::Engine::Middleware::ReverseProxy> for L<HTTP::Engine>.

Nobuo Danjou

Masahiro Nagano

Tatsuhiko Miyagawa

=head1 SEE ALSO

L<HTTP::Engine::Middleware::ReverseProxy>

L<Plack>

L<Plack::Middleware>

L<Plack::Middleware::Conditional>

=cut
